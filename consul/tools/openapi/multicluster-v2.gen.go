// Package multicluster provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package multicluster

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes        = "BearerAuth.Scopes"
	ConsulTokenHeaderScopes = "ConsulTokenHeader.Scopes"
)

// Defines values for HashicorpConsulResourceConditionState.
const (
	STATEFALSE   HashicorpConsulResourceConditionState = "STATE_FALSE"
	STATETRUE    HashicorpConsulResourceConditionState = "STATE_TRUE"
	STATEUNKNOWN HashicorpConsulResourceConditionState = "STATE_UNKNOWN"
)

// HashicorpConsulMulticlusterV2ComputedExportedService defines model for hashicorp.consul.multicluster.v2.ComputedExportedService.
type HashicorpConsulMulticlusterV2ComputedExportedService struct {
	Consumers *[]HashicorpConsulMulticlusterV2ComputedExportedServicesConsumer `json:"consumers,omitempty"`

	// TargetRef  Reference identifies which resource a condition relates to, when it is not
	//  the core resource itself.
	TargetRef *HashicorpConsulResourceReference `json:"target_ref,omitempty"`
}

// HashicorpConsulMulticlusterV2ComputedExportedServices defines model for hashicorp.consul.multicluster.v2.ComputedExportedServices.
type HashicorpConsulMulticlusterV2ComputedExportedServices struct {
	Consumers *[]HashicorpConsulMulticlusterV2ComputedExportedService `json:"consumers,omitempty"`
}

// HashicorpConsulMulticlusterV2ComputedExportedServicesConsumer defines model for hashicorp.consul.multicluster.v2.ComputedExportedServicesConsumer.
type HashicorpConsulMulticlusterV2ComputedExportedServicesConsumer struct {
	Partition *string `json:"partition,omitempty"`
	Peer      *string `json:"peer,omitempty"`
}

// HashicorpConsulMulticlusterV2ExportedServices defines model for hashicorp.consul.multicluster.v2.ExportedServices.
type HashicorpConsulMulticlusterV2ExportedServices struct {
	Consumers *[]HashicorpConsulMulticlusterV2ExportedServicesConsumer `json:"consumers,omitempty"`
	Services  *[]string                                                `json:"services,omitempty"`
}

// HashicorpConsulMulticlusterV2ExportedServicesConsumer defines model for hashicorp.consul.multicluster.v2.ExportedServicesConsumer.
type HashicorpConsulMulticlusterV2ExportedServicesConsumer struct {
	Partition     *string `json:"partition,omitempty"`
	Peer          *string `json:"peer,omitempty"`
	SamenessGroup *string `json:"sameness_group,omitempty"`
}

// HashicorpConsulMulticlusterV2NamespaceExportedServices defines model for hashicorp.consul.multicluster.v2.NamespaceExportedServices.
type HashicorpConsulMulticlusterV2NamespaceExportedServices struct {
	Consumers *[]HashicorpConsulMulticlusterV2ExportedServicesConsumer `json:"consumers,omitempty"`
}

// HashicorpConsulMulticlusterV2PartitionExportedServices defines model for hashicorp.consul.multicluster.v2.PartitionExportedServices.
type HashicorpConsulMulticlusterV2PartitionExportedServices struct {
	Consumers *[]HashicorpConsulMulticlusterV2ExportedServicesConsumer `json:"consumers,omitempty"`
}

// HashicorpConsulResourceCondition  Condition represents a discreet observation about a resource in relation to
//
//	the current state of the system.
//	It is heavily inspired by Kubernetes' [conditions](https://bit.ly/3H9Y6IK)
//	and the Gateway API [types and reasons](https://bit.ly/3n2PPiP).
type HashicorpConsulResourceCondition struct {
	// Message // Message contains a human-friendly description of the status.
	Message *string `json:"message,omitempty"`

	// Reason // Reason provides more machine-readable details about the condition (e.g.
	// // "InvalidProtocol").
	Reason *string `json:"reason,omitempty"`

	// Resource  Reference identifies which resource a condition relates to, when it is not
	//  the core resource itself.
	Resource *HashicorpConsulResourceReference `json:"resource,omitempty"`

	// State  State represents the state of the condition (i.e. true/false/unknown).
	State *HashicorpConsulResourceConditionState `json:"state,omitempty"`

	// Type // Type identifies the type of condition (e.g. "Invalid", "ResolvedRefs").
	Type *string `json:"type,omitempty"`
}

// HashicorpConsulResourceConditionState  State represents the state of the condition (i.e. true/false/unknown).
type HashicorpConsulResourceConditionState string

// HashicorpConsulResourceID  ID uniquely identifies a resource.
type HashicorpConsulResourceID struct {
	// Name // Name is the user-given name of the resource (e.g. the "billing" service).
	Name *string `json:"name,omitempty"`

	// Tenancy  Tenancy describes the tenancy units in which the resource resides.
	Tenancy *HashicorpConsulResourceTenancy `json:"tenancy,omitempty"`

	// Type  Type describes a resource's type. It follows the GVK (Group Version Kind)
	//  [pattern](https://book.kubebuilder.io/cronjob-tutorial/gvks.html) established
	//  by Kubernetes.
	Type *HashicorpConsulResourceType `json:"type,omitempty"`

	// Uid // Uid is the unique internal identifier we gave to the resource.
	// //
	// // It is primarily used to tell the difference between the current resource
	// // and previous deleted resources with the same user-given name.
	// //
	// // Concretely, Uid is a [ULID](https://github.com/ulid/spec) and you can treat
	// // its timestamp component as the resource's creation time.
	Uid *string `json:"uid,omitempty"`
}

// HashicorpConsulResourceReference  Reference identifies which resource a condition relates to, when it is not
//
//	the core resource itself.
type HashicorpConsulResourceReference struct {
	// Name // Name is the user-given name of the resource (e.g. the "billing" service).
	Name *string `json:"name,omitempty"`

	// Section // Section identifies which part of the resource the condition relates to.
	Section *string `json:"section,omitempty"`

	// Tenancy  Tenancy describes the tenancy units in which the resource resides.
	Tenancy *HashicorpConsulResourceTenancy `json:"tenancy,omitempty"`

	// Type  Type describes a resource's type. It follows the GVK (Group Version Kind)
	//  [pattern](https://book.kubebuilder.io/cronjob-tutorial/gvks.html) established
	//  by Kubernetes.
	Type *HashicorpConsulResourceType `json:"type,omitempty"`
}

// HashicorpConsulResourceStatus  Status is used by controllers to communicate the result of attempting to
//
//	reconcile and apply a resource (e.g. surface semantic validation errors)
//	with users and other controllers.
type HashicorpConsulResourceStatus struct {
	// Conditions // Conditions contains a set of discreet observations about the resource in
	// // relation to the current state of the system (e.g. it is semantically valid).
	Conditions *[]HashicorpConsulResourceCondition `json:"conditions,omitempty"`

	// ObservedGeneration // ObservedGeneration identifies which generation of a resource this status
	// // related to. It can be used to determine whether the current generation of
	// // a resource has been reconciled.
	ObservedGeneration *string `json:"observed_generation,omitempty"`

	// UpdatedAt // UpdatedAt is the time at which the status was last written.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// HashicorpConsulResourceTenancy  Tenancy describes the tenancy units in which the resource resides.
type HashicorpConsulResourceTenancy struct {
	// Namespace // Namespace further isolates resources within a partition.
	// // https://developer.hashicorp.com/consul/docs/enterprise/namespaces
	// //
	// // When using the List and WatchList endpoints, provide the wildcard value "*"
	// // to list resources across all namespaces.
	Namespace *string `json:"namespace,omitempty"`

	// Partition // Partition is the topmost administrative boundary within a cluster.
	// // https://developer.hashicorp.com/consul/docs/enterprise/admin-partitions
	// //
	// // When using the List and WatchList endpoints, provide the wildcard value "*"
	// // to list resources across all partitions.
	Partition *string `json:"partition,omitempty"`

	// PeerName // PeerName identifies which peer the resource is imported from.
	// // https://developer.hashicorp.com/consul/docs/connect/cluster-peering
	// //
	// // When using the List and WatchList endpoints, provide the wildcard value "*"
	// // to list resources across all peers.
	PeerName *string `json:"peer_name,omitempty"`
}

// HashicorpConsulResourceType  Type describes a resource's type. It follows the GVK (Group Version Kind)
//
//	[pattern](https://book.kubebuilder.io/cronjob-tutorial/gvks.html) established
//	by Kubernetes.
type HashicorpConsulResourceType struct {
	// Group // Group describes the area of functionality to which this resource type
	// // relates (e.g. "catalog", "authorization").
	Group *string `json:"group,omitempty"`

	// GroupVersion // GroupVersion is incremented when sweeping or backward-incompatible changes
	// // are made to the group's resource types.
	GroupVersion *string `json:"group_version,omitempty"`

	// Kind // Kind identifies the specific resource type within the group.
	Kind *string `json:"kind,omitempty"`
}

// Consistent defines model for consistent.
type Consistent = bool

// Name defines model for name.
type Name = string

// NamePrefix defines model for name_prefix.
type NamePrefix = string

// Namespace defines model for namespace.
type Namespace = string

// Ns defines model for ns.
type Ns = string

// Partition defines model for partition.
type Partition = string

// Peer defines model for peer.
type Peer = string

// ListComputedExportedServicesParams defines parameters for ListComputedExportedServices.
type ListComputedExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Consistent When true, the operation will be performed with strong consistency
	Consistent *Consistent `form:"consistent,omitempty" json:"consistent,omitempty"`

	// NamePrefix The resource name prefix used to filter the result list.
	NamePrefix *NamePrefix `form:"name_prefix,omitempty" json:"name_prefix,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// DeleteComputedExportedServicesParams defines parameters for DeleteComputedExportedServices.
type DeleteComputedExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// ReadComputedExportedServicesParams defines parameters for ReadComputedExportedServices.
type ReadComputedExportedServicesParams struct {
	// Consistent When true, the operation will be performed with strong consistency
	Consistent *Consistent `form:"consistent,omitempty" json:"consistent,omitempty"`

	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// WriteComputedExportedServicesJSONBody defines parameters for WriteComputedExportedServices.
type WriteComputedExportedServicesJSONBody struct {
	Data *HashicorpConsulMulticlusterV2ComputedExportedServices `json:"data,omitempty"`

	// Generation // Generation is incremented whenever the resource's content (i.e. not its
	// // status) is modified. You can think of it as being the "user version".
	// //
	// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
	// // can treat its timestamp component as the resource's modification time.
	Generation *string `json:"generation,omitempty"`

	// Id  ID uniquely identifies a resource.
	Id *HashicorpConsulResourceID `json:"id,omitempty"`

	// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
	// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// Owner  ID uniquely identifies a resource.
	Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

	// Status // Status is used by controllers to communicate the result of attempting to
	// // reconcile and apply the resource (e.g. surface semantic validation errors)
	// // with users and other controllers. Each status is identified by a unique key
	// // and should only ever be updated by one controller.
	// //
	// // Status can only be updated via the WriteStatus endpoint. Attempting to do
	// // so via the Write endpoint will result in an InvalidArgument error code.
	Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

	// Version // Version is the low-level version identifier used by the storage backend
	// // in CAS (Compare-And-Swap) operations. It will change when the resource is
	// // modified in any way, including status updates.
	// //
	// // When calling the Write endpoint, providing a non-blank version will perform
	// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
	// // if the given version doesn't match what is stored.
	Version *string `json:"version,omitempty"`
}

// WriteComputedExportedServicesParams defines parameters for WriteComputedExportedServices.
type WriteComputedExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// ListExportedServicesParams defines parameters for ListExportedServices.
type ListExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Consistent When true, the operation will be performed with strong consistency
	Consistent *Consistent `form:"consistent,omitempty" json:"consistent,omitempty"`

	// NamePrefix The resource name prefix used to filter the result list.
	NamePrefix *NamePrefix `form:"name_prefix,omitempty" json:"name_prefix,omitempty"`

	// Namespace Specifies the Consul namespace of resources to operate on. This parameter takes precedence over the `ns` alias.
	Namespace *Namespace `form:"namespace,omitempty" json:"namespace,omitempty"`

	// Ns `ns` is an alias for the `namespace` query param. The `namespace` parameter takes precedence.
	Ns *Ns `form:"ns,omitempty" json:"ns,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// DeleteExportedServicesParams defines parameters for DeleteExportedServices.
type DeleteExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Namespace Specifies the Consul namespace of resources to operate on. This parameter takes precedence over the `ns` alias.
	Namespace *Namespace `form:"namespace,omitempty" json:"namespace,omitempty"`

	// Ns `ns` is an alias for the `namespace` query param. The `namespace` parameter takes precedence.
	Ns *Ns `form:"ns,omitempty" json:"ns,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// ReadExportedServicesParams defines parameters for ReadExportedServices.
type ReadExportedServicesParams struct {
	// Consistent When true, the operation will be performed with strong consistency
	Consistent *Consistent `form:"consistent,omitempty" json:"consistent,omitempty"`

	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Namespace Specifies the Consul namespace of resources to operate on. This parameter takes precedence over the `ns` alias.
	Namespace *Namespace `form:"namespace,omitempty" json:"namespace,omitempty"`

	// Ns `ns` is an alias for the `namespace` query param. The `namespace` parameter takes precedence.
	Ns *Ns `form:"ns,omitempty" json:"ns,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// WriteExportedServicesJSONBody defines parameters for WriteExportedServices.
type WriteExportedServicesJSONBody struct {
	Data *HashicorpConsulMulticlusterV2ExportedServices `json:"data,omitempty"`

	// Generation // Generation is incremented whenever the resource's content (i.e. not its
	// // status) is modified. You can think of it as being the "user version".
	// //
	// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
	// // can treat its timestamp component as the resource's modification time.
	Generation *string `json:"generation,omitempty"`

	// Id  ID uniquely identifies a resource.
	Id *HashicorpConsulResourceID `json:"id,omitempty"`

	// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
	// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// Owner  ID uniquely identifies a resource.
	Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

	// Status // Status is used by controllers to communicate the result of attempting to
	// // reconcile and apply the resource (e.g. surface semantic validation errors)
	// // with users and other controllers. Each status is identified by a unique key
	// // and should only ever be updated by one controller.
	// //
	// // Status can only be updated via the WriteStatus endpoint. Attempting to do
	// // so via the Write endpoint will result in an InvalidArgument error code.
	Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

	// Version // Version is the low-level version identifier used by the storage backend
	// // in CAS (Compare-And-Swap) operations. It will change when the resource is
	// // modified in any way, including status updates.
	// //
	// // When calling the Write endpoint, providing a non-blank version will perform
	// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
	// // if the given version doesn't match what is stored.
	Version *string `json:"version,omitempty"`
}

// WriteExportedServicesParams defines parameters for WriteExportedServices.
type WriteExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Namespace Specifies the Consul namespace of resources to operate on. This parameter takes precedence over the `ns` alias.
	Namespace *Namespace `form:"namespace,omitempty" json:"namespace,omitempty"`

	// Ns `ns` is an alias for the `namespace` query param. The `namespace` parameter takes precedence.
	Ns *Ns `form:"ns,omitempty" json:"ns,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// ListNamespaceExportedServicesParams defines parameters for ListNamespaceExportedServices.
type ListNamespaceExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Consistent When true, the operation will be performed with strong consistency
	Consistent *Consistent `form:"consistent,omitempty" json:"consistent,omitempty"`

	// NamePrefix The resource name prefix used to filter the result list.
	NamePrefix *NamePrefix `form:"name_prefix,omitempty" json:"name_prefix,omitempty"`

	// Namespace Specifies the Consul namespace of resources to operate on. This parameter takes precedence over the `ns` alias.
	Namespace *Namespace `form:"namespace,omitempty" json:"namespace,omitempty"`

	// Ns `ns` is an alias for the `namespace` query param. The `namespace` parameter takes precedence.
	Ns *Ns `form:"ns,omitempty" json:"ns,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// DeleteNamespaceExportedServicesParams defines parameters for DeleteNamespaceExportedServices.
type DeleteNamespaceExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Namespace Specifies the Consul namespace of resources to operate on. This parameter takes precedence over the `ns` alias.
	Namespace *Namespace `form:"namespace,omitempty" json:"namespace,omitempty"`

	// Ns `ns` is an alias for the `namespace` query param. The `namespace` parameter takes precedence.
	Ns *Ns `form:"ns,omitempty" json:"ns,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// ReadNamespaceExportedServicesParams defines parameters for ReadNamespaceExportedServices.
type ReadNamespaceExportedServicesParams struct {
	// Consistent When true, the operation will be performed with strong consistency
	Consistent *Consistent `form:"consistent,omitempty" json:"consistent,omitempty"`

	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Namespace Specifies the Consul namespace of resources to operate on. This parameter takes precedence over the `ns` alias.
	Namespace *Namespace `form:"namespace,omitempty" json:"namespace,omitempty"`

	// Ns `ns` is an alias for the `namespace` query param. The `namespace` parameter takes precedence.
	Ns *Ns `form:"ns,omitempty" json:"ns,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// WriteNamespaceExportedServicesJSONBody defines parameters for WriteNamespaceExportedServices.
type WriteNamespaceExportedServicesJSONBody struct {
	Data *HashicorpConsulMulticlusterV2NamespaceExportedServices `json:"data,omitempty"`

	// Generation // Generation is incremented whenever the resource's content (i.e. not its
	// // status) is modified. You can think of it as being the "user version".
	// //
	// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
	// // can treat its timestamp component as the resource's modification time.
	Generation *string `json:"generation,omitempty"`

	// Id  ID uniquely identifies a resource.
	Id *HashicorpConsulResourceID `json:"id,omitempty"`

	// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
	// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// Owner  ID uniquely identifies a resource.
	Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

	// Status // Status is used by controllers to communicate the result of attempting to
	// // reconcile and apply the resource (e.g. surface semantic validation errors)
	// // with users and other controllers. Each status is identified by a unique key
	// // and should only ever be updated by one controller.
	// //
	// // Status can only be updated via the WriteStatus endpoint. Attempting to do
	// // so via the Write endpoint will result in an InvalidArgument error code.
	Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

	// Version // Version is the low-level version identifier used by the storage backend
	// // in CAS (Compare-And-Swap) operations. It will change when the resource is
	// // modified in any way, including status updates.
	// //
	// // When calling the Write endpoint, providing a non-blank version will perform
	// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
	// // if the given version doesn't match what is stored.
	Version *string `json:"version,omitempty"`
}

// WriteNamespaceExportedServicesParams defines parameters for WriteNamespaceExportedServices.
type WriteNamespaceExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Namespace Specifies the Consul namespace of resources to operate on. This parameter takes precedence over the `ns` alias.
	Namespace *Namespace `form:"namespace,omitempty" json:"namespace,omitempty"`

	// Ns `ns` is an alias for the `namespace` query param. The `namespace` parameter takes precedence.
	Ns *Ns `form:"ns,omitempty" json:"ns,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// ListPartitionExportedServicesParams defines parameters for ListPartitionExportedServices.
type ListPartitionExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Consistent When true, the operation will be performed with strong consistency
	Consistent *Consistent `form:"consistent,omitempty" json:"consistent,omitempty"`

	// NamePrefix The resource name prefix used to filter the result list.
	NamePrefix *NamePrefix `form:"name_prefix,omitempty" json:"name_prefix,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// DeletePartitionExportedServicesParams defines parameters for DeletePartitionExportedServices.
type DeletePartitionExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// ReadPartitionExportedServicesParams defines parameters for ReadPartitionExportedServices.
type ReadPartitionExportedServicesParams struct {
	// Consistent When true, the operation will be performed with strong consistency
	Consistent *Consistent `form:"consistent,omitempty" json:"consistent,omitempty"`

	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// WritePartitionExportedServicesJSONBody defines parameters for WritePartitionExportedServices.
type WritePartitionExportedServicesJSONBody struct {
	Data *HashicorpConsulMulticlusterV2PartitionExportedServices `json:"data,omitempty"`

	// Generation // Generation is incremented whenever the resource's content (i.e. not its
	// // status) is modified. You can think of it as being the "user version".
	// //
	// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
	// // can treat its timestamp component as the resource's modification time.
	Generation *string `json:"generation,omitempty"`

	// Id  ID uniquely identifies a resource.
	Id *HashicorpConsulResourceID `json:"id,omitempty"`

	// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
	// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// Owner  ID uniquely identifies a resource.
	Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

	// Status // Status is used by controllers to communicate the result of attempting to
	// // reconcile and apply the resource (e.g. surface semantic validation errors)
	// // with users and other controllers. Each status is identified by a unique key
	// // and should only ever be updated by one controller.
	// //
	// // Status can only be updated via the WriteStatus endpoint. Attempting to do
	// // so via the Write endpoint will result in an InvalidArgument error code.
	Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

	// Version // Version is the low-level version identifier used by the storage backend
	// // in CAS (Compare-And-Swap) operations. It will change when the resource is
	// // modified in any way, including status updates.
	// //
	// // When calling the Write endpoint, providing a non-blank version will perform
	// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
	// // if the given version doesn't match what is stored.
	Version *string `json:"version,omitempty"`
}

// WritePartitionExportedServicesParams defines parameters for WritePartitionExportedServices.
type WritePartitionExportedServicesParams struct {
	// Peer Specifies the Consul peer of imported resources to operate on.
	Peer *Peer `form:"peer,omitempty" json:"peer,omitempty"`

	// Partition Specifies the Consul partition of resources to operate on.
	Partition *Partition `form:"partition,omitempty" json:"partition,omitempty"`
}

// WriteComputedExportedServicesJSONRequestBody defines body for WriteComputedExportedServices for application/json ContentType.
type WriteComputedExportedServicesJSONRequestBody WriteComputedExportedServicesJSONBody

// WriteExportedServicesJSONRequestBody defines body for WriteExportedServices for application/json ContentType.
type WriteExportedServicesJSONRequestBody WriteExportedServicesJSONBody

// WriteNamespaceExportedServicesJSONRequestBody defines body for WriteNamespaceExportedServices for application/json ContentType.
type WriteNamespaceExportedServicesJSONRequestBody WriteNamespaceExportedServicesJSONBody

// WritePartitionExportedServicesJSONRequestBody defines body for WritePartitionExportedServices for application/json ContentType.
type WritePartitionExportedServicesJSONRequestBody WritePartitionExportedServicesJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListComputedExportedServices request
	ListComputedExportedServices(ctx context.Context, params *ListComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComputedExportedServices request
	DeleteComputedExportedServices(ctx context.Context, name Name, params *DeleteComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadComputedExportedServices request
	ReadComputedExportedServices(ctx context.Context, name Name, params *ReadComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WriteComputedExportedServicesWithBody request with any body
	WriteComputedExportedServicesWithBody(ctx context.Context, name Name, params *WriteComputedExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WriteComputedExportedServices(ctx context.Context, name Name, params *WriteComputedExportedServicesParams, body WriteComputedExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListExportedServices request
	ListExportedServices(ctx context.Context, params *ListExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExportedServices request
	DeleteExportedServices(ctx context.Context, name Name, params *DeleteExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadExportedServices request
	ReadExportedServices(ctx context.Context, name Name, params *ReadExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WriteExportedServicesWithBody request with any body
	WriteExportedServicesWithBody(ctx context.Context, name Name, params *WriteExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WriteExportedServices(ctx context.Context, name Name, params *WriteExportedServicesParams, body WriteExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNamespaceExportedServices request
	ListNamespaceExportedServices(ctx context.Context, params *ListNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNamespaceExportedServices request
	DeleteNamespaceExportedServices(ctx context.Context, name Name, params *DeleteNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadNamespaceExportedServices request
	ReadNamespaceExportedServices(ctx context.Context, name Name, params *ReadNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WriteNamespaceExportedServicesWithBody request with any body
	WriteNamespaceExportedServicesWithBody(ctx context.Context, name Name, params *WriteNamespaceExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WriteNamespaceExportedServices(ctx context.Context, name Name, params *WriteNamespaceExportedServicesParams, body WriteNamespaceExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPartitionExportedServices request
	ListPartitionExportedServices(ctx context.Context, params *ListPartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePartitionExportedServices request
	DeletePartitionExportedServices(ctx context.Context, name Name, params *DeletePartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadPartitionExportedServices request
	ReadPartitionExportedServices(ctx context.Context, name Name, params *ReadPartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WritePartitionExportedServicesWithBody request with any body
	WritePartitionExportedServicesWithBody(ctx context.Context, name Name, params *WritePartitionExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WritePartitionExportedServices(ctx context.Context, name Name, params *WritePartitionExportedServicesParams, body WritePartitionExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListComputedExportedServices(ctx context.Context, params *ListComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListComputedExportedServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComputedExportedServices(ctx context.Context, name Name, params *DeleteComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteComputedExportedServicesRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadComputedExportedServices(ctx context.Context, name Name, params *ReadComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadComputedExportedServicesRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WriteComputedExportedServicesWithBody(ctx context.Context, name Name, params *WriteComputedExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWriteComputedExportedServicesRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WriteComputedExportedServices(ctx context.Context, name Name, params *WriteComputedExportedServicesParams, body WriteComputedExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWriteComputedExportedServicesRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListExportedServices(ctx context.Context, params *ListExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListExportedServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExportedServices(ctx context.Context, name Name, params *DeleteExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExportedServicesRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadExportedServices(ctx context.Context, name Name, params *ReadExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadExportedServicesRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WriteExportedServicesWithBody(ctx context.Context, name Name, params *WriteExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWriteExportedServicesRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WriteExportedServices(ctx context.Context, name Name, params *WriteExportedServicesParams, body WriteExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWriteExportedServicesRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNamespaceExportedServices(ctx context.Context, params *ListNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNamespaceExportedServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNamespaceExportedServices(ctx context.Context, name Name, params *DeleteNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNamespaceExportedServicesRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadNamespaceExportedServices(ctx context.Context, name Name, params *ReadNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadNamespaceExportedServicesRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WriteNamespaceExportedServicesWithBody(ctx context.Context, name Name, params *WriteNamespaceExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWriteNamespaceExportedServicesRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WriteNamespaceExportedServices(ctx context.Context, name Name, params *WriteNamespaceExportedServicesParams, body WriteNamespaceExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWriteNamespaceExportedServicesRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPartitionExportedServices(ctx context.Context, params *ListPartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPartitionExportedServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePartitionExportedServices(ctx context.Context, name Name, params *DeletePartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePartitionExportedServicesRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadPartitionExportedServices(ctx context.Context, name Name, params *ReadPartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadPartitionExportedServicesRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WritePartitionExportedServicesWithBody(ctx context.Context, name Name, params *WritePartitionExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWritePartitionExportedServicesRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WritePartitionExportedServices(ctx context.Context, name Name, params *WritePartitionExportedServicesParams, body WritePartitionExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWritePartitionExportedServicesRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListComputedExportedServicesRequest generates requests for ListComputedExportedServices
func NewListComputedExportedServicesRequest(server string, params *ListComputedExportedServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/ComputedExportedServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Consistent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistent", runtime.ParamLocationQuery, *params.Consistent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamePrefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name_prefix", runtime.ParamLocationQuery, *params.NamePrefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteComputedExportedServicesRequest generates requests for DeleteComputedExportedServices
func NewDeleteComputedExportedServicesRequest(server string, name Name, params *DeleteComputedExportedServicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/ComputedExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadComputedExportedServicesRequest generates requests for ReadComputedExportedServices
func NewReadComputedExportedServicesRequest(server string, name Name, params *ReadComputedExportedServicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/ComputedExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Consistent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistent", runtime.ParamLocationQuery, *params.Consistent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWriteComputedExportedServicesRequest calls the generic WriteComputedExportedServices builder with application/json body
func NewWriteComputedExportedServicesRequest(server string, name Name, params *WriteComputedExportedServicesParams, body WriteComputedExportedServicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWriteComputedExportedServicesRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewWriteComputedExportedServicesRequestWithBody generates requests for WriteComputedExportedServices with any type of body
func NewWriteComputedExportedServicesRequestWithBody(server string, name Name, params *WriteComputedExportedServicesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/ComputedExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListExportedServicesRequest generates requests for ListExportedServices
func NewListExportedServicesRequest(server string, params *ListExportedServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/ExportedServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Consistent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistent", runtime.ParamLocationQuery, *params.Consistent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamePrefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name_prefix", runtime.ParamLocationQuery, *params.NamePrefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ns", runtime.ParamLocationQuery, *params.Ns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteExportedServicesRequest generates requests for DeleteExportedServices
func NewDeleteExportedServicesRequest(server string, name Name, params *DeleteExportedServicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/ExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ns", runtime.ParamLocationQuery, *params.Ns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadExportedServicesRequest generates requests for ReadExportedServices
func NewReadExportedServicesRequest(server string, name Name, params *ReadExportedServicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/ExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Consistent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistent", runtime.ParamLocationQuery, *params.Consistent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ns", runtime.ParamLocationQuery, *params.Ns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWriteExportedServicesRequest calls the generic WriteExportedServices builder with application/json body
func NewWriteExportedServicesRequest(server string, name Name, params *WriteExportedServicesParams, body WriteExportedServicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWriteExportedServicesRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewWriteExportedServicesRequestWithBody generates requests for WriteExportedServices with any type of body
func NewWriteExportedServicesRequestWithBody(server string, name Name, params *WriteExportedServicesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/ExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ns", runtime.ParamLocationQuery, *params.Ns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNamespaceExportedServicesRequest generates requests for ListNamespaceExportedServices
func NewListNamespaceExportedServicesRequest(server string, params *ListNamespaceExportedServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/NamespaceExportedServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Consistent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistent", runtime.ParamLocationQuery, *params.Consistent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamePrefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name_prefix", runtime.ParamLocationQuery, *params.NamePrefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ns", runtime.ParamLocationQuery, *params.Ns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNamespaceExportedServicesRequest generates requests for DeleteNamespaceExportedServices
func NewDeleteNamespaceExportedServicesRequest(server string, name Name, params *DeleteNamespaceExportedServicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/NamespaceExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ns", runtime.ParamLocationQuery, *params.Ns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadNamespaceExportedServicesRequest generates requests for ReadNamespaceExportedServices
func NewReadNamespaceExportedServicesRequest(server string, name Name, params *ReadNamespaceExportedServicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/NamespaceExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Consistent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistent", runtime.ParamLocationQuery, *params.Consistent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ns", runtime.ParamLocationQuery, *params.Ns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWriteNamespaceExportedServicesRequest calls the generic WriteNamespaceExportedServices builder with application/json body
func NewWriteNamespaceExportedServicesRequest(server string, name Name, params *WriteNamespaceExportedServicesParams, body WriteNamespaceExportedServicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWriteNamespaceExportedServicesRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewWriteNamespaceExportedServicesRequestWithBody generates requests for WriteNamespaceExportedServices with any type of body
func NewWriteNamespaceExportedServicesRequestWithBody(server string, name Name, params *WriteNamespaceExportedServicesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/NamespaceExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ns", runtime.ParamLocationQuery, *params.Ns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPartitionExportedServicesRequest generates requests for ListPartitionExportedServices
func NewListPartitionExportedServicesRequest(server string, params *ListPartitionExportedServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/PartitionExportedServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Consistent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistent", runtime.ParamLocationQuery, *params.Consistent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamePrefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name_prefix", runtime.ParamLocationQuery, *params.NamePrefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePartitionExportedServicesRequest generates requests for DeletePartitionExportedServices
func NewDeletePartitionExportedServicesRequest(server string, name Name, params *DeletePartitionExportedServicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/PartitionExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadPartitionExportedServicesRequest generates requests for ReadPartitionExportedServices
func NewReadPartitionExportedServicesRequest(server string, name Name, params *ReadPartitionExportedServicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/PartitionExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Consistent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "consistent", runtime.ParamLocationQuery, *params.Consistent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWritePartitionExportedServicesRequest calls the generic WritePartitionExportedServices builder with application/json body
func NewWritePartitionExportedServicesRequest(server string, name Name, params *WritePartitionExportedServicesParams, body WritePartitionExportedServicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWritePartitionExportedServicesRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewWritePartitionExportedServicesRequestWithBody generates requests for WritePartitionExportedServices with any type of body
func NewWritePartitionExportedServicesRequestWithBody(server string, name Name, params *WritePartitionExportedServicesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/multicluster/v2/PartitionExportedServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Peer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer", runtime.ParamLocationQuery, *params.Peer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListComputedExportedServicesWithResponse request
	ListComputedExportedServicesWithResponse(ctx context.Context, params *ListComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*ListComputedExportedServicesResponse, error)

	// DeleteComputedExportedServicesWithResponse request
	DeleteComputedExportedServicesWithResponse(ctx context.Context, name Name, params *DeleteComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*DeleteComputedExportedServicesResponse, error)

	// ReadComputedExportedServicesWithResponse request
	ReadComputedExportedServicesWithResponse(ctx context.Context, name Name, params *ReadComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*ReadComputedExportedServicesResponse, error)

	// WriteComputedExportedServicesWithBodyWithResponse request with any body
	WriteComputedExportedServicesWithBodyWithResponse(ctx context.Context, name Name, params *WriteComputedExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WriteComputedExportedServicesResponse, error)

	WriteComputedExportedServicesWithResponse(ctx context.Context, name Name, params *WriteComputedExportedServicesParams, body WriteComputedExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*WriteComputedExportedServicesResponse, error)

	// ListExportedServicesWithResponse request
	ListExportedServicesWithResponse(ctx context.Context, params *ListExportedServicesParams, reqEditors ...RequestEditorFn) (*ListExportedServicesResponse, error)

	// DeleteExportedServicesWithResponse request
	DeleteExportedServicesWithResponse(ctx context.Context, name Name, params *DeleteExportedServicesParams, reqEditors ...RequestEditorFn) (*DeleteExportedServicesResponse, error)

	// ReadExportedServicesWithResponse request
	ReadExportedServicesWithResponse(ctx context.Context, name Name, params *ReadExportedServicesParams, reqEditors ...RequestEditorFn) (*ReadExportedServicesResponse, error)

	// WriteExportedServicesWithBodyWithResponse request with any body
	WriteExportedServicesWithBodyWithResponse(ctx context.Context, name Name, params *WriteExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WriteExportedServicesResponse, error)

	WriteExportedServicesWithResponse(ctx context.Context, name Name, params *WriteExportedServicesParams, body WriteExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*WriteExportedServicesResponse, error)

	// ListNamespaceExportedServicesWithResponse request
	ListNamespaceExportedServicesWithResponse(ctx context.Context, params *ListNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*ListNamespaceExportedServicesResponse, error)

	// DeleteNamespaceExportedServicesWithResponse request
	DeleteNamespaceExportedServicesWithResponse(ctx context.Context, name Name, params *DeleteNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceExportedServicesResponse, error)

	// ReadNamespaceExportedServicesWithResponse request
	ReadNamespaceExportedServicesWithResponse(ctx context.Context, name Name, params *ReadNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*ReadNamespaceExportedServicesResponse, error)

	// WriteNamespaceExportedServicesWithBodyWithResponse request with any body
	WriteNamespaceExportedServicesWithBodyWithResponse(ctx context.Context, name Name, params *WriteNamespaceExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WriteNamespaceExportedServicesResponse, error)

	WriteNamespaceExportedServicesWithResponse(ctx context.Context, name Name, params *WriteNamespaceExportedServicesParams, body WriteNamespaceExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*WriteNamespaceExportedServicesResponse, error)

	// ListPartitionExportedServicesWithResponse request
	ListPartitionExportedServicesWithResponse(ctx context.Context, params *ListPartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*ListPartitionExportedServicesResponse, error)

	// DeletePartitionExportedServicesWithResponse request
	DeletePartitionExportedServicesWithResponse(ctx context.Context, name Name, params *DeletePartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*DeletePartitionExportedServicesResponse, error)

	// ReadPartitionExportedServicesWithResponse request
	ReadPartitionExportedServicesWithResponse(ctx context.Context, name Name, params *ReadPartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*ReadPartitionExportedServicesResponse, error)

	// WritePartitionExportedServicesWithBodyWithResponse request with any body
	WritePartitionExportedServicesWithBodyWithResponse(ctx context.Context, name Name, params *WritePartitionExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WritePartitionExportedServicesResponse, error)

	WritePartitionExportedServicesWithResponse(ctx context.Context, name Name, params *WritePartitionExportedServicesParams, body WritePartitionExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*WritePartitionExportedServicesResponse, error)
}

type ListComputedExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Data *HashicorpConsulMulticlusterV2ComputedExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListComputedExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListComputedExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteComputedExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteComputedExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteComputedExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadComputedExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *HashicorpConsulMulticlusterV2ComputedExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadComputedExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadComputedExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WriteComputedExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *HashicorpConsulMulticlusterV2ComputedExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WriteComputedExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WriteComputedExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Data *HashicorpConsulMulticlusterV2ExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *HashicorpConsulMulticlusterV2ExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WriteExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *HashicorpConsulMulticlusterV2ExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WriteExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WriteExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNamespaceExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Data *HashicorpConsulMulticlusterV2NamespaceExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListNamespaceExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNamespaceExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNamespaceExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNamespaceExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNamespaceExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadNamespaceExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *HashicorpConsulMulticlusterV2NamespaceExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadNamespaceExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadNamespaceExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WriteNamespaceExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *HashicorpConsulMulticlusterV2NamespaceExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WriteNamespaceExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WriteNamespaceExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPartitionExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Data *HashicorpConsulMulticlusterV2PartitionExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPartitionExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPartitionExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePartitionExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePartitionExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePartitionExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadPartitionExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *HashicorpConsulMulticlusterV2PartitionExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReadPartitionExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadPartitionExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WritePartitionExportedServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *HashicorpConsulMulticlusterV2PartitionExportedServices `json:"data,omitempty"`

		// Generation // Generation is incremented whenever the resource's content (i.e. not its
		// // status) is modified. You can think of it as being the "user version".
		// //
		// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
		// // can treat its timestamp component as the resource's modification time.
		Generation *string `json:"generation,omitempty"`

		// Id  ID uniquely identifies a resource.
		Id *HashicorpConsulResourceID `json:"id,omitempty"`

		// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
		// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
		Metadata *map[string]string `json:"metadata,omitempty"`

		// Owner  ID uniquely identifies a resource.
		Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

		// Status // Status is used by controllers to communicate the result of attempting to
		// // reconcile and apply the resource (e.g. surface semantic validation errors)
		// // with users and other controllers. Each status is identified by a unique key
		// // and should only ever be updated by one controller.
		// //
		// // Status can only be updated via the WriteStatus endpoint. Attempting to do
		// // so via the Write endpoint will result in an InvalidArgument error code.
		Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

		// Version // Version is the low-level version identifier used by the storage backend
		// // in CAS (Compare-And-Swap) operations. It will change when the resource is
		// // modified in any way, including status updates.
		// //
		// // When calling the Write endpoint, providing a non-blank version will perform
		// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
		// // if the given version doesn't match what is stored.
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WritePartitionExportedServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WritePartitionExportedServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListComputedExportedServicesWithResponse request returning *ListComputedExportedServicesResponse
func (c *ClientWithResponses) ListComputedExportedServicesWithResponse(ctx context.Context, params *ListComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*ListComputedExportedServicesResponse, error) {
	rsp, err := c.ListComputedExportedServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListComputedExportedServicesResponse(rsp)
}

// DeleteComputedExportedServicesWithResponse request returning *DeleteComputedExportedServicesResponse
func (c *ClientWithResponses) DeleteComputedExportedServicesWithResponse(ctx context.Context, name Name, params *DeleteComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*DeleteComputedExportedServicesResponse, error) {
	rsp, err := c.DeleteComputedExportedServices(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteComputedExportedServicesResponse(rsp)
}

// ReadComputedExportedServicesWithResponse request returning *ReadComputedExportedServicesResponse
func (c *ClientWithResponses) ReadComputedExportedServicesWithResponse(ctx context.Context, name Name, params *ReadComputedExportedServicesParams, reqEditors ...RequestEditorFn) (*ReadComputedExportedServicesResponse, error) {
	rsp, err := c.ReadComputedExportedServices(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadComputedExportedServicesResponse(rsp)
}

// WriteComputedExportedServicesWithBodyWithResponse request with arbitrary body returning *WriteComputedExportedServicesResponse
func (c *ClientWithResponses) WriteComputedExportedServicesWithBodyWithResponse(ctx context.Context, name Name, params *WriteComputedExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WriteComputedExportedServicesResponse, error) {
	rsp, err := c.WriteComputedExportedServicesWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWriteComputedExportedServicesResponse(rsp)
}

func (c *ClientWithResponses) WriteComputedExportedServicesWithResponse(ctx context.Context, name Name, params *WriteComputedExportedServicesParams, body WriteComputedExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*WriteComputedExportedServicesResponse, error) {
	rsp, err := c.WriteComputedExportedServices(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWriteComputedExportedServicesResponse(rsp)
}

// ListExportedServicesWithResponse request returning *ListExportedServicesResponse
func (c *ClientWithResponses) ListExportedServicesWithResponse(ctx context.Context, params *ListExportedServicesParams, reqEditors ...RequestEditorFn) (*ListExportedServicesResponse, error) {
	rsp, err := c.ListExportedServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListExportedServicesResponse(rsp)
}

// DeleteExportedServicesWithResponse request returning *DeleteExportedServicesResponse
func (c *ClientWithResponses) DeleteExportedServicesWithResponse(ctx context.Context, name Name, params *DeleteExportedServicesParams, reqEditors ...RequestEditorFn) (*DeleteExportedServicesResponse, error) {
	rsp, err := c.DeleteExportedServices(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExportedServicesResponse(rsp)
}

// ReadExportedServicesWithResponse request returning *ReadExportedServicesResponse
func (c *ClientWithResponses) ReadExportedServicesWithResponse(ctx context.Context, name Name, params *ReadExportedServicesParams, reqEditors ...RequestEditorFn) (*ReadExportedServicesResponse, error) {
	rsp, err := c.ReadExportedServices(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadExportedServicesResponse(rsp)
}

// WriteExportedServicesWithBodyWithResponse request with arbitrary body returning *WriteExportedServicesResponse
func (c *ClientWithResponses) WriteExportedServicesWithBodyWithResponse(ctx context.Context, name Name, params *WriteExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WriteExportedServicesResponse, error) {
	rsp, err := c.WriteExportedServicesWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWriteExportedServicesResponse(rsp)
}

func (c *ClientWithResponses) WriteExportedServicesWithResponse(ctx context.Context, name Name, params *WriteExportedServicesParams, body WriteExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*WriteExportedServicesResponse, error) {
	rsp, err := c.WriteExportedServices(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWriteExportedServicesResponse(rsp)
}

// ListNamespaceExportedServicesWithResponse request returning *ListNamespaceExportedServicesResponse
func (c *ClientWithResponses) ListNamespaceExportedServicesWithResponse(ctx context.Context, params *ListNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*ListNamespaceExportedServicesResponse, error) {
	rsp, err := c.ListNamespaceExportedServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNamespaceExportedServicesResponse(rsp)
}

// DeleteNamespaceExportedServicesWithResponse request returning *DeleteNamespaceExportedServicesResponse
func (c *ClientWithResponses) DeleteNamespaceExportedServicesWithResponse(ctx context.Context, name Name, params *DeleteNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*DeleteNamespaceExportedServicesResponse, error) {
	rsp, err := c.DeleteNamespaceExportedServices(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNamespaceExportedServicesResponse(rsp)
}

// ReadNamespaceExportedServicesWithResponse request returning *ReadNamespaceExportedServicesResponse
func (c *ClientWithResponses) ReadNamespaceExportedServicesWithResponse(ctx context.Context, name Name, params *ReadNamespaceExportedServicesParams, reqEditors ...RequestEditorFn) (*ReadNamespaceExportedServicesResponse, error) {
	rsp, err := c.ReadNamespaceExportedServices(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadNamespaceExportedServicesResponse(rsp)
}

// WriteNamespaceExportedServicesWithBodyWithResponse request with arbitrary body returning *WriteNamespaceExportedServicesResponse
func (c *ClientWithResponses) WriteNamespaceExportedServicesWithBodyWithResponse(ctx context.Context, name Name, params *WriteNamespaceExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WriteNamespaceExportedServicesResponse, error) {
	rsp, err := c.WriteNamespaceExportedServicesWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWriteNamespaceExportedServicesResponse(rsp)
}

func (c *ClientWithResponses) WriteNamespaceExportedServicesWithResponse(ctx context.Context, name Name, params *WriteNamespaceExportedServicesParams, body WriteNamespaceExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*WriteNamespaceExportedServicesResponse, error) {
	rsp, err := c.WriteNamespaceExportedServices(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWriteNamespaceExportedServicesResponse(rsp)
}

// ListPartitionExportedServicesWithResponse request returning *ListPartitionExportedServicesResponse
func (c *ClientWithResponses) ListPartitionExportedServicesWithResponse(ctx context.Context, params *ListPartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*ListPartitionExportedServicesResponse, error) {
	rsp, err := c.ListPartitionExportedServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPartitionExportedServicesResponse(rsp)
}

// DeletePartitionExportedServicesWithResponse request returning *DeletePartitionExportedServicesResponse
func (c *ClientWithResponses) DeletePartitionExportedServicesWithResponse(ctx context.Context, name Name, params *DeletePartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*DeletePartitionExportedServicesResponse, error) {
	rsp, err := c.DeletePartitionExportedServices(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePartitionExportedServicesResponse(rsp)
}

// ReadPartitionExportedServicesWithResponse request returning *ReadPartitionExportedServicesResponse
func (c *ClientWithResponses) ReadPartitionExportedServicesWithResponse(ctx context.Context, name Name, params *ReadPartitionExportedServicesParams, reqEditors ...RequestEditorFn) (*ReadPartitionExportedServicesResponse, error) {
	rsp, err := c.ReadPartitionExportedServices(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadPartitionExportedServicesResponse(rsp)
}

// WritePartitionExportedServicesWithBodyWithResponse request with arbitrary body returning *WritePartitionExportedServicesResponse
func (c *ClientWithResponses) WritePartitionExportedServicesWithBodyWithResponse(ctx context.Context, name Name, params *WritePartitionExportedServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WritePartitionExportedServicesResponse, error) {
	rsp, err := c.WritePartitionExportedServicesWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWritePartitionExportedServicesResponse(rsp)
}

func (c *ClientWithResponses) WritePartitionExportedServicesWithResponse(ctx context.Context, name Name, params *WritePartitionExportedServicesParams, body WritePartitionExportedServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*WritePartitionExportedServicesResponse, error) {
	rsp, err := c.WritePartitionExportedServices(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWritePartitionExportedServicesResponse(rsp)
}

// ParseListComputedExportedServicesResponse parses an HTTP response from a ListComputedExportedServicesWithResponse call
func ParseListComputedExportedServicesResponse(rsp *http.Response) (*ListComputedExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListComputedExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Data *HashicorpConsulMulticlusterV2ComputedExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteComputedExportedServicesResponse parses an HTTP response from a DeleteComputedExportedServicesWithResponse call
func ParseDeleteComputedExportedServicesResponse(rsp *http.Response) (*DeleteComputedExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteComputedExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadComputedExportedServicesResponse parses an HTTP response from a ReadComputedExportedServicesWithResponse call
func ParseReadComputedExportedServicesResponse(rsp *http.Response) (*ReadComputedExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadComputedExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *HashicorpConsulMulticlusterV2ComputedExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWriteComputedExportedServicesResponse parses an HTTP response from a WriteComputedExportedServicesWithResponse call
func ParseWriteComputedExportedServicesResponse(rsp *http.Response) (*WriteComputedExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WriteComputedExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *HashicorpConsulMulticlusterV2ComputedExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListExportedServicesResponse parses an HTTP response from a ListExportedServicesWithResponse call
func ParseListExportedServicesResponse(rsp *http.Response) (*ListExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Data *HashicorpConsulMulticlusterV2ExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteExportedServicesResponse parses an HTTP response from a DeleteExportedServicesWithResponse call
func ParseDeleteExportedServicesResponse(rsp *http.Response) (*DeleteExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadExportedServicesResponse parses an HTTP response from a ReadExportedServicesWithResponse call
func ParseReadExportedServicesResponse(rsp *http.Response) (*ReadExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *HashicorpConsulMulticlusterV2ExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWriteExportedServicesResponse parses an HTTP response from a WriteExportedServicesWithResponse call
func ParseWriteExportedServicesResponse(rsp *http.Response) (*WriteExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WriteExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *HashicorpConsulMulticlusterV2ExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListNamespaceExportedServicesResponse parses an HTTP response from a ListNamespaceExportedServicesWithResponse call
func ParseListNamespaceExportedServicesResponse(rsp *http.Response) (*ListNamespaceExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNamespaceExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Data *HashicorpConsulMulticlusterV2NamespaceExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNamespaceExportedServicesResponse parses an HTTP response from a DeleteNamespaceExportedServicesWithResponse call
func ParseDeleteNamespaceExportedServicesResponse(rsp *http.Response) (*DeleteNamespaceExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNamespaceExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadNamespaceExportedServicesResponse parses an HTTP response from a ReadNamespaceExportedServicesWithResponse call
func ParseReadNamespaceExportedServicesResponse(rsp *http.Response) (*ReadNamespaceExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadNamespaceExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *HashicorpConsulMulticlusterV2NamespaceExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWriteNamespaceExportedServicesResponse parses an HTTP response from a WriteNamespaceExportedServicesWithResponse call
func ParseWriteNamespaceExportedServicesResponse(rsp *http.Response) (*WriteNamespaceExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WriteNamespaceExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *HashicorpConsulMulticlusterV2NamespaceExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPartitionExportedServicesResponse parses an HTTP response from a ListPartitionExportedServicesWithResponse call
func ParseListPartitionExportedServicesResponse(rsp *http.Response) (*ListPartitionExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPartitionExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Data *HashicorpConsulMulticlusterV2PartitionExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePartitionExportedServicesResponse parses an HTTP response from a DeletePartitionExportedServicesWithResponse call
func ParseDeletePartitionExportedServicesResponse(rsp *http.Response) (*DeletePartitionExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePartitionExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadPartitionExportedServicesResponse parses an HTTP response from a ReadPartitionExportedServicesWithResponse call
func ParseReadPartitionExportedServicesResponse(rsp *http.Response) (*ReadPartitionExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadPartitionExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *HashicorpConsulMulticlusterV2PartitionExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWritePartitionExportedServicesResponse parses an HTTP response from a WritePartitionExportedServicesWithResponse call
func ParseWritePartitionExportedServicesResponse(rsp *http.Response) (*WritePartitionExportedServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WritePartitionExportedServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *HashicorpConsulMulticlusterV2PartitionExportedServices `json:"data,omitempty"`

			// Generation // Generation is incremented whenever the resource's content (i.e. not its
			// // status) is modified. You can think of it as being the "user version".
			// //
			// // Concretely, Generation is a [ULID](https://github.com/ulid/spec) and you
			// // can treat its timestamp component as the resource's modification time.
			Generation *string `json:"generation,omitempty"`

			// Id  ID uniquely identifies a resource.
			Id *HashicorpConsulResourceID `json:"id,omitempty"`

			// Metadata // Metadata contains key/value pairs of arbitrary metadata about the resource.
			// // "deletionTimestamp" and "finalizers" keys are reserved for internal use.
			Metadata *map[string]string `json:"metadata,omitempty"`

			// Owner  ID uniquely identifies a resource.
			Owner *HashicorpConsulResourceID `json:"owner,omitempty"`

			// Status // Status is used by controllers to communicate the result of attempting to
			// // reconcile and apply the resource (e.g. surface semantic validation errors)
			// // with users and other controllers. Each status is identified by a unique key
			// // and should only ever be updated by one controller.
			// //
			// // Status can only be updated via the WriteStatus endpoint. Attempting to do
			// // so via the Write endpoint will result in an InvalidArgument error code.
			Status *map[string]HashicorpConsulResourceStatus `json:"status,omitempty"`

			// Version // Version is the low-level version identifier used by the storage backend
			// // in CAS (Compare-And-Swap) operations. It will change when the resource is
			// // modified in any way, including status updates.
			// //
			// // When calling the Write endpoint, providing a non-blank version will perform
			// // a CAS (Compare-And-Swap) write, which will result in an Aborted error code
			// // if the given version doesn't match what is stored.
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List multicluster.v2.ComputedExportedServices resources
	// (GET /multicluster/v2/ComputedExportedServices)
	ListComputedExportedServices(ctx echo.Context, params ListComputedExportedServicesParams) error
	// Delete multicluster.v2.ComputedExportedServices resources
	// (DELETE /multicluster/v2/ComputedExportedServices/{name})
	DeleteComputedExportedServices(ctx echo.Context, name Name, params DeleteComputedExportedServicesParams) error
	// Read multicluster.v2.ComputedExportedServices resources
	// (GET /multicluster/v2/ComputedExportedServices/{name})
	ReadComputedExportedServices(ctx echo.Context, name Name, params ReadComputedExportedServicesParams) error
	// Write multicluster.v2.ComputedExportedServices resources
	// (PUT /multicluster/v2/ComputedExportedServices/{name})
	WriteComputedExportedServices(ctx echo.Context, name Name, params WriteComputedExportedServicesParams) error
	// List multicluster.v2.ExportedServices resources
	// (GET /multicluster/v2/ExportedServices)
	ListExportedServices(ctx echo.Context, params ListExportedServicesParams) error
	// Delete multicluster.v2.ExportedServices resources
	// (DELETE /multicluster/v2/ExportedServices/{name})
	DeleteExportedServices(ctx echo.Context, name Name, params DeleteExportedServicesParams) error
	// Read multicluster.v2.ExportedServices resources
	// (GET /multicluster/v2/ExportedServices/{name})
	ReadExportedServices(ctx echo.Context, name Name, params ReadExportedServicesParams) error
	// Write multicluster.v2.ExportedServices resources
	// (PUT /multicluster/v2/ExportedServices/{name})
	WriteExportedServices(ctx echo.Context, name Name, params WriteExportedServicesParams) error
	// List multicluster.v2.NamespaceExportedServices resources
	// (GET /multicluster/v2/NamespaceExportedServices)
	ListNamespaceExportedServices(ctx echo.Context, params ListNamespaceExportedServicesParams) error
	// Delete multicluster.v2.NamespaceExportedServices resources
	// (DELETE /multicluster/v2/NamespaceExportedServices/{name})
	DeleteNamespaceExportedServices(ctx echo.Context, name Name, params DeleteNamespaceExportedServicesParams) error
	// Read multicluster.v2.NamespaceExportedServices resources
	// (GET /multicluster/v2/NamespaceExportedServices/{name})
	ReadNamespaceExportedServices(ctx echo.Context, name Name, params ReadNamespaceExportedServicesParams) error
	// Write multicluster.v2.NamespaceExportedServices resources
	// (PUT /multicluster/v2/NamespaceExportedServices/{name})
	WriteNamespaceExportedServices(ctx echo.Context, name Name, params WriteNamespaceExportedServicesParams) error
	// List multicluster.v2.PartitionExportedServices resources
	// (GET /multicluster/v2/PartitionExportedServices)
	ListPartitionExportedServices(ctx echo.Context, params ListPartitionExportedServicesParams) error
	// Delete multicluster.v2.PartitionExportedServices resources
	// (DELETE /multicluster/v2/PartitionExportedServices/{name})
	DeletePartitionExportedServices(ctx echo.Context, name Name, params DeletePartitionExportedServicesParams) error
	// Read multicluster.v2.PartitionExportedServices resources
	// (GET /multicluster/v2/PartitionExportedServices/{name})
	ReadPartitionExportedServices(ctx echo.Context, name Name, params ReadPartitionExportedServicesParams) error
	// Write multicluster.v2.PartitionExportedServices resources
	// (PUT /multicluster/v2/PartitionExportedServices/{name})
	WritePartitionExportedServices(ctx echo.Context, name Name, params WritePartitionExportedServicesParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListComputedExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) ListComputedExportedServices(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{"write:TrafficPermissions.destination"})

	ctx.Set(ConsulTokenHeaderScopes, []string{"write:TrafficPermissions.destination"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListComputedExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "consistent" -------------

	err = runtime.BindQueryParameter("form", true, false, "consistent", ctx.QueryParams(), &params.Consistent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consistent: %s", err))
	}

	// ------------- Optional query parameter "name_prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "name_prefix", ctx.QueryParams(), &params.NamePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name_prefix: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListComputedExportedServices(ctx, params)
	return err
}

// DeleteComputedExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteComputedExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteComputedExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteComputedExportedServices(ctx, name, params)
	return err
}

// ReadComputedExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) ReadComputedExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ReadComputedExportedServicesParams
	// ------------- Optional query parameter "consistent" -------------

	err = runtime.BindQueryParameter("form", true, false, "consistent", ctx.QueryParams(), &params.Consistent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consistent: %s", err))
	}

	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReadComputedExportedServices(ctx, name, params)
	return err
}

// WriteComputedExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) WriteComputedExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params WriteComputedExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WriteComputedExportedServices(ctx, name, params)
	return err
}

// ListExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) ListExportedServices(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{"write:TrafficPermissions.destination"})

	ctx.Set(ConsulTokenHeaderScopes, []string{"write:TrafficPermissions.destination"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "consistent" -------------

	err = runtime.BindQueryParameter("form", true, false, "consistent", ctx.QueryParams(), &params.Consistent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consistent: %s", err))
	}

	// ------------- Optional query parameter "name_prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "name_prefix", ctx.QueryParams(), &params.NamePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name_prefix: %s", err))
	}

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Optional query parameter "ns" -------------

	err = runtime.BindQueryParameter("form", true, false, "ns", ctx.QueryParams(), &params.Ns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ns: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListExportedServices(ctx, params)
	return err
}

// DeleteExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Optional query parameter "ns" -------------

	err = runtime.BindQueryParameter("form", true, false, "ns", ctx.QueryParams(), &params.Ns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ns: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteExportedServices(ctx, name, params)
	return err
}

// ReadExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) ReadExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ReadExportedServicesParams
	// ------------- Optional query parameter "consistent" -------------

	err = runtime.BindQueryParameter("form", true, false, "consistent", ctx.QueryParams(), &params.Consistent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consistent: %s", err))
	}

	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Optional query parameter "ns" -------------

	err = runtime.BindQueryParameter("form", true, false, "ns", ctx.QueryParams(), &params.Ns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ns: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReadExportedServices(ctx, name, params)
	return err
}

// WriteExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) WriteExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params WriteExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Optional query parameter "ns" -------------

	err = runtime.BindQueryParameter("form", true, false, "ns", ctx.QueryParams(), &params.Ns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ns: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WriteExportedServices(ctx, name, params)
	return err
}

// ListNamespaceExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) ListNamespaceExportedServices(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{"write:TrafficPermissions.destination"})

	ctx.Set(ConsulTokenHeaderScopes, []string{"write:TrafficPermissions.destination"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNamespaceExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "consistent" -------------

	err = runtime.BindQueryParameter("form", true, false, "consistent", ctx.QueryParams(), &params.Consistent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consistent: %s", err))
	}

	// ------------- Optional query parameter "name_prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "name_prefix", ctx.QueryParams(), &params.NamePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name_prefix: %s", err))
	}

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Optional query parameter "ns" -------------

	err = runtime.BindQueryParameter("form", true, false, "ns", ctx.QueryParams(), &params.Ns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ns: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListNamespaceExportedServices(ctx, params)
	return err
}

// DeleteNamespaceExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteNamespaceExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteNamespaceExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Optional query parameter "ns" -------------

	err = runtime.BindQueryParameter("form", true, false, "ns", ctx.QueryParams(), &params.Ns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ns: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteNamespaceExportedServices(ctx, name, params)
	return err
}

// ReadNamespaceExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) ReadNamespaceExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ReadNamespaceExportedServicesParams
	// ------------- Optional query parameter "consistent" -------------

	err = runtime.BindQueryParameter("form", true, false, "consistent", ctx.QueryParams(), &params.Consistent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consistent: %s", err))
	}

	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Optional query parameter "ns" -------------

	err = runtime.BindQueryParameter("form", true, false, "ns", ctx.QueryParams(), &params.Ns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ns: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReadNamespaceExportedServices(ctx, name, params)
	return err
}

// WriteNamespaceExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) WriteNamespaceExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params WriteNamespaceExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, false, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// ------------- Optional query parameter "ns" -------------

	err = runtime.BindQueryParameter("form", true, false, "ns", ctx.QueryParams(), &params.Ns)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ns: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WriteNamespaceExportedServices(ctx, name, params)
	return err
}

// ListPartitionExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) ListPartitionExportedServices(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{"write:TrafficPermissions.destination"})

	ctx.Set(ConsulTokenHeaderScopes, []string{"write:TrafficPermissions.destination"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPartitionExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "consistent" -------------

	err = runtime.BindQueryParameter("form", true, false, "consistent", ctx.QueryParams(), &params.Consistent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consistent: %s", err))
	}

	// ------------- Optional query parameter "name_prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "name_prefix", ctx.QueryParams(), &params.NamePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name_prefix: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListPartitionExportedServices(ctx, params)
	return err
}

// DeletePartitionExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) DeletePartitionExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeletePartitionExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeletePartitionExportedServices(ctx, name, params)
	return err
}

// ReadPartitionExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) ReadPartitionExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ReadPartitionExportedServicesParams
	// ------------- Optional query parameter "consistent" -------------

	err = runtime.BindQueryParameter("form", true, false, "consistent", ctx.QueryParams(), &params.Consistent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter consistent: %s", err))
	}

	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReadPartitionExportedServices(ctx, name, params)
	return err
}

// WritePartitionExportedServices converts echo context to params.
func (w *ServerInterfaceWrapper) WritePartitionExportedServices(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(ConsulTokenHeaderScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params WritePartitionExportedServicesParams
	// ------------- Optional query parameter "peer" -------------

	err = runtime.BindQueryParameter("form", true, false, "peer", ctx.QueryParams(), &params.Peer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter peer: %s", err))
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", true, false, "partition", ctx.QueryParams(), &params.Partition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter partition: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WritePartitionExportedServices(ctx, name, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/multicluster/v2/ComputedExportedServices", wrapper.ListComputedExportedServices)
	router.DELETE(baseURL+"/multicluster/v2/ComputedExportedServices/:name", wrapper.DeleteComputedExportedServices)
	router.GET(baseURL+"/multicluster/v2/ComputedExportedServices/:name", wrapper.ReadComputedExportedServices)
	router.PUT(baseURL+"/multicluster/v2/ComputedExportedServices/:name", wrapper.WriteComputedExportedServices)
	router.GET(baseURL+"/multicluster/v2/ExportedServices", wrapper.ListExportedServices)
	router.DELETE(baseURL+"/multicluster/v2/ExportedServices/:name", wrapper.DeleteExportedServices)
	router.GET(baseURL+"/multicluster/v2/ExportedServices/:name", wrapper.ReadExportedServices)
	router.PUT(baseURL+"/multicluster/v2/ExportedServices/:name", wrapper.WriteExportedServices)
	router.GET(baseURL+"/multicluster/v2/NamespaceExportedServices", wrapper.ListNamespaceExportedServices)
	router.DELETE(baseURL+"/multicluster/v2/NamespaceExportedServices/:name", wrapper.DeleteNamespaceExportedServices)
	router.GET(baseURL+"/multicluster/v2/NamespaceExportedServices/:name", wrapper.ReadNamespaceExportedServices)
	router.PUT(baseURL+"/multicluster/v2/NamespaceExportedServices/:name", wrapper.WriteNamespaceExportedServices)
	router.GET(baseURL+"/multicluster/v2/PartitionExportedServices", wrapper.ListPartitionExportedServices)
	router.DELETE(baseURL+"/multicluster/v2/PartitionExportedServices/:name", wrapper.DeletePartitionExportedServices)
	router.GET(baseURL+"/multicluster/v2/PartitionExportedServices/:name", wrapper.ReadPartitionExportedServices)
	router.PUT(baseURL+"/multicluster/v2/PartitionExportedServices/:name", wrapper.WritePartitionExportedServices)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+ydb2/bONLAvwqh5wHaHmyr6AIHXN5l21436F43aNLtLeogS4tjixuKVEnKXm2R734Y",
	"Uv8cS47jpFenx1e7jiRyOBzO/GY4QL9EicpyJUFaEx19iXKqaQYWtPuVKGm4sSAt/mJgEs1zy5WMjqKP",
	"KUhidQEjYlMgKgdN8RFZcSHIDEgOeq50BoysuE2JsVrJBWmGTMpoFHEc6XMBGn9ImkF01J10FJkkhYzi",
	"7LbM8elMKQFURtfX9Qc3BTtPgeATouZOMg1GFToBYlUlJRAlJ/XsObVpO7n7zyjS8LngGlh05Fa4KYax",
	"mstFI8VlrmHO/+wXphHASeXfJIUBhhLNubCga0ELYYngxk4GdNOd63apTE6THgWd5ZDwOQfjZn2ppCkE",
	"ad5HtdUSmxs6I+cpN6SxEWLpFRhcUQIMJH67rNbyuzS/Eyo4NduW4gW8ZSFmcwVudG4IlX4OMlf1tPWo",
	"vxM3nxcWBV9/OLyGQXnNLYLmVFvuBdxJ48372zQ+IEw71y0yAehdxQHQKAnPcqUtsDuLhFNtk+a6fug2",
	"NKUm5YnS+SRx80+yQlieiMJY0JPli8lLleWFBfb6Ty/PGegl9+acaxTHcmicVJFVHotbyNz//L+GeXQU",
	"/V/c+re4mj7ed27zspoquh7Vy6Na09L9pnoB9tJNe8fpa01P3sMcNBqh27xqBjX7AxKLU+wt97dU2qau",
	"HnRpzZZsLHHtPN4wxvZkbJ6Zu8v2TdR9F9s0HcGa2TdU8gC79JV3ZxQZmoEEYy4XWhX5Q23guzowHPhO",
	"7rW401rT38PiGlf5Ukk2EG1J84xoyDUYlJhQwrhJNIAlaoYHwtMqnanCEtpCGsevhH9o1VS6GJkUWoO0",
	"xFgXBD1YmtJYyCZTSU4s0kgKdMlFSbg0OcIjmZXkbTEDLcGCeUI+JbVc5uJpam1ujuJ4xu1ElPEPP/3j",
	"t7+fvH02lYRK5oZ/Qy2saEmOT0/IJ9SMcY80UNM7gnxxespPn02mCAXr+5qBMXTRg4JxTP7lnyGYW8ol",
	"KiotMirHc81BMlGSzifN0i21hfFTbZxRL2HvZO/dI5JrteQMDMmUBpLRJOUSxhooozMBhIGlXJhqb5z+",
	"mx19CpPFZCrjmEyjE7mkgrNTraxKlJhGzwYl8pv7IJF5FDkr2H+sxjwnZ26gxvB7FHZe5kA4A2lbYMOX",
	"cSNuKKVVyDQakWn0HowSS2DvYW6GVLPnmasE3zx57u/dU1cbS3NoOkLzCUxcBhnPqTAQF/JKqpWsJAVZ",
	"ZNHRp+js/Pj89eWHd2/f/fLxXTSqfp+///C6+fHP45/PXkcXPRs/vJaTVz3in7wiheSfC8BT3Cq99Q59",
	"h6s/C41jglEF/QIuuzCgxwu+BNmfm/odxD9NoxkXgsvFNCJV3B4yawuSYh69tyWeVwN0LHDPgfDr61FU",
	"cNarig+cNZpwCiZcWtCSilbPmqyALOjSJepd5bjj7o6897O55hnV6GnrJNqCEO4TxufVOSUzsCuAdfdd",
	"j+gGQ2eaa1hyVRjCQMB60uOKFs58cb9u7F8r0kslEw0WRDmqV0nJpw8/n7xqPfSC27SYTRKVxYXgLDY5",
	"JM/c/KUqSEIlsRqodeNxPDQ8A2NplpNmEwg1azp5YkiC37goxTN4gNPdurjNg9E86x6LVcqTtDVh2jnb",
	"LoK6zHFEVilIwt3OSWXrgIqOv4251oCYH9bhMpD040UckzP/bFMZSLWbdac1t9eq5pGc6rtZ0Zkjg4HQ",
	"UBjcMndqZ6UjDq2EAO1KDInKskLyBINFpxym5oRaC1luuVx4ItOQKJlwAe4M0TwXZZfg/HabQs9pAsRA",
	"RqXlCXGh0Z8Y0Fppg7DlTjnaj4crZVPQXcH6bLLFuF7jaKKk6TKVAbeUPgbtgk4HQ5076KDobSBarduf",
	"tHrVVIjSr7yy8/2ovge7e9JMvyZglwuQVTW4V0O/VO+9aV7bPEntEM4CuqcJl+eMqdWQCwMTjA/oTWfQ",
	"RAYGFnTGJaAbcpvb1eLaJD4otBOl1JAZRpDG3NjAiS1yhiJcUtsf/PzjY1v7K3TYhNpqpS1PkxU1RFBj",
	"yUpza0H6+eZKZzh0hMOM8eP7uvrz1sXcOKXVk4r5ZzVxVn8tJIYnLjuSN+rSYBDph5z4QC268uS+8jwv",
	"tNsibpT3kevRmEtC26qpTwLqEMtgCQLnnHRXncV+5TFTiYkBkSPX3EDcSGSaQO7uMwrjnEwK5GdurHMJ",
	"H6lNUvcLJMsVl9aM6gTGvbnigiVUMzxmBYaYv00jN6JVrpbfWQVNtDKGUNGptw9lUVvKyXFMmqS+sSmV",
	"ZwpFZhmX3Fg06yWQmSoko7psFVjn5vdRn5tk3Ej4zZTYSjCkRAB9OcgQpwDac8RGHIf2Tqbyx6atjM+1",
	"yu6uv0RJCYmNqw0Y4xxIIt9Kd9CEt/v5kt7U1SeurRehXXLF0Z2znish1Mob8Jtf35Knb7QqcvIraIOm",
	"/ZZLhkH6U44EoGWn5qHU1eSqmMGs4IKBnnAVJ1rJP9RsbAurNKciXiyvzCS1mXhGEKdngpsU2FSu12X6",
	"HFZTXNwwGS/gunekGigGqXkhHRZSwW2Jyq+9JDed8FXm0IlbpsndE2qpUAufu9PCpkrzv1xsGq5rODkv",
	"l15dw/LW+kQbxmwlw6PMPJibFUCONqc0mdHkakU1G3OJUEAtnwkgSUrlwjtKXCrJKGtSNCfAkxvLGzqM",
	"V1z2Z4e4zzeLHMbfUSXrQ9durJl7RwP2PF9obsszZBy/zT8C1aCPC5viLwc/7orZ/bkdFo0O5fcXZefq",
	"CuRPQJmvULursNT/bO7C/j32747dy+1INOdvofR3YVzO1aY2qsu449MTf6np0mSaOPZtMtJujbXVD6rX",
	"IFZU9kCWL3BmbgW0A3c/jUZRYzrR8oUjuBwkzXl0FP0weT55jgeD2tQpK+5+Gi9fxNsumxbgUKhpCjhh",
	"0VGEPmzwo9Fa68Gnfj5tX4ndDcH16Nb3Ot0EO7zdvV/f4fU2Rl9fuCpjrqTxGnjx/HmVK9TtE5inYHbD",
	"lYz/qAqk7W1pw+XrnohRS7/adaZzIdtRvYvom94DljfC5BOf8yBb+/KeVBaze+c8POQ+w4EyxfCoswn5",
	"ra6ApFxeuftnV+uYQR0HpxGmZ7VRT6P+0su6nHerwLjBmirMHSowfhXJLVWYUeSLYvslXCevcIQMLK1N",
	"gTKfgVFxumYqG9P2lPr9KG1eegVl7Kkhp1wbl2rpGbcakbGetCc9rSvwrmzGlTyv9TWNnFan0ZxjHPwL",
	"tJlGOI1xsUODz/xa3yapwGRtTXMtdqiV9G72PsozTUliSHX7jV6VOvo0/XDFDkcKm+WOnvrWTgWPOL69",
	"5EFe0yStU1I89XVkdguhdQX3CsqmjmpSVQhGlBQlcU4BU3Cf9uI3SkJnhvYEV2rCs+c+7Xy15NQt8qPm",
	"Fqr3av6dkOOukgjzejJq/avmfd+SVqkYkyBJqpuSY70o0J95BZFEsSFL3AZZHb7CyYVajQUmBE0k7tS4",
	"a3vwWb/SdAGOu0AyX/+V5OXxGXmKPptqGB9LNj5b0fxZ22FnHDu7NXk28yR3I11xo9V+1q+6JCtajtCL",
	"i4Kh7qo99jo3k/VUJKGuUtqjzzr9wKeUSCXHM0HlVbNcJ1rV/ldVVQbWtMJxRxUob+7S8cwnXO3ueB35",
	"spev+NaTMgVGPrEkw3SJrFLq62BW6YG6TV+ac+NGeuNon+P2cuNxjBpiiiQBY+aFaK5tZ4qVrYP1+YGm",
	"ZdXkVQhrJms86mCnS6KfIqeVo3NN53OenILOuDFu3xng1D5aX/QC6a4fI6+YIsuoLisyI7tSQ5tOunXs",
	"zIXxF6Sra3+CBPj7w3VCfOX+voUR+xBrc4f88LtvkN+XalsapXhh9lLLqB+A3wNlDwbAXbC9L3wG5gzM",
	"GZgzMGdgzsCcgTn/q8zZz5gaKLsvvyBt7EkvX6cU54qjd66q5UUPSTnb2MqJnwsw9kfFygBCAYQCCAUQ",
	"CiAUQCiA0GMDoTvzC5pka8mTqvs/lEYCEQQiCEQQiCAQQSCCR00ETsb71ka8Ah/qxutOHVDfR+dT29K9",
	"y8vmO2qmCtQWqC1QW6C2QG2B2gK1hSaq7U1U90XJnZumDrNZas8mqe+9OSowZGDIwJCBIQNDBoYMDPnN",
	"m6IOuRnqqxfahvurDruvKjBUYKjAUIGhAkMFhgoMtW8/1WPuowoEEAggEEAggEAAgQACARxA/9RdL7u2",
	"/rMLgw1Uw1+FTqpH1Uk1vJEB5ALIBZALIBdALoBcALnQUrUbNuyNmzs3WW1DzwPottpJM1varh6OrA+8",
	"/yqQZyDPQJ6BPAN5BvIM5Hk4jVg7Asz/bEfWdv48mNasgFcBrwJeBbwKeBXwKuDVvXu0bqeiR9CsFZgg",
	"MEFggsAEgQkCEwQmOKSurb3v05p/g/ZO7VvDX4V/AvDr9VoNaz3gV8CvgF8BvwJ+BfwK+BV6rXbDhr3Z",
	"cOdeq22ceAC9VjtpZkuv1cNh8IH3WgXyDOQZyDOQZyDPQJ6BPA+n12pHgHkc/xTgdlg8mMaowEKBhQIL",
	"BRYKLBRYKLDQvRujbkeYR9AYFZggMEFggsAEgQkCEwQmOKTGqN0uv7Ze411cj770XtFdXF9c/ycAAP//",
	"tT6UkHy1AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
